<?xml version="1.0" encoding="iso-8859-1"?>
<document title="XP::Tasks::RDBMS">
  <main>
    <references>
      <ref link="tasks">Common tasks</ref>
      <ref type="devel" link="writingsql">Writing SQL</ref>
    </references>
    <content>
      <title>The XP rdbms API</title>
      <editor>$Id$</editor>
      
      <para>
        <caption>How to use the XP framework's rdbms access API</caption>
        <text>
          The <ref type="api:collection" link="rdbms"/> api offers a unified way
          of accessing database servers, such as MySQL, Sybase, PostgreSQL and 
          more. The different database APIs existing in PHP are not unified: For instance,
          the order of parameters varies between the sybase and postgresql extensions,
          oracle is completely different from mysql and so on.
          <br/><br/>
          The XP api provides a driver-based model to retrieve the specialized 
          connection classes and then offers a standardized way of accessing 
          rdbms functionality through them.
        </text>
      </para>
      
      <para>
        <caption>The DriverManager model</caption>
        <text>
          To retrieve a connection class from the driver manager, you need to use
          the <ref type="api:class" link="rdbms.DriverManager"/> class.
          
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager');

  $conn= &DriverManager::getConnection(
    'sybase://user:pass@server/NICOTINE'
  ); ]]></code>

          <box caption="Note:">
            Do not instanciate the database connection classes themselves, always
            use the above model to retrieve a connection.
          </box>
            
          The DriverManager class expects a unified connection string (we call it <b>DSN</b>)
          specifying the following:
          <ul>
            <li>
              The driver (here: <tt>sybase</tt>).<br/>
              This corresponds either to a <ref link="tasks.rdbms#3">built-in driver class</ref>
              or one you have previously registered to it.
            </li>
            <li>
              An optional username and password (here: <tt>user</tt> and <tt>pass</tt>).
            </li>
            <li>
              The hostname of the rdbms (here: <tt>server</tt>).<br/>
              Hostname is not completely correct: in SQLite, for example, this
              specifies the name of the data file; in Sybase, it corresponds to an
              entry in the interfaces file.
            </li>
            <li>
              The database name (here: <tt>NICOTINE</tt>).<br/>
              May be ommitted - for instance, Sybase offers a per-user default database 
              setting which automatically selects the specified database after log in.
            </li>
            <li>
              Optional parameters (here: <i>none</i>).<br/>
              The most commonly used one is <tt>autoconnect</tt>. For a complete list,
              see <ref link="tasks.rdbms#4">below</ref>.
            </li>
          </ul>
        </text>
      </para>
      
      <para>
        <caption>The DriverManager model: Drivers</caption>
        <text>
          Built-in drivers supported:
          <ul>
            <li><b>sybase</b> - <ref type="api:class" link="rdbms.sybase.SybaseConnection"/></li>
            <li><b>mysql</b> - <ref type="api:class" link="rdbms.mysql.MySQLConnection"/></li>
            <li><b>pgsql</b> - <ref type="api:class" link="rdbms.pgsql.PostgreSQLConnection"/></li>
            <li><b>sqlite</b> - <ref type="api:class" link="rdbms.sqlite.SQLiteConnection"/></li>
          </ul>
          
          To register your own driver, you can use the <ref type="api:class" link="rdbms.DriverManager#register"/>
          method.
          
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager');

  DriverManager::register(
    'mydb', 
    XPClass::forName('de.thekid.rdbms.MyDB')
  );
  $conn= &DriverManager::getConnection('mydb://localhost'); ]]></code>
          <box caption="Note:">
            User-defined connection classes must extend the <ref type="api:class" link="rdbms.DBConnection"/>
            class.
          </box>
        </text>
      </para>
      
      <para>
        <caption>The DriverManager model: DSN parameters</caption>
        <text>
          Parameters in DSN are used in a key-value syntax as known from HTTP urls, e.g.
          <tt>mysql://user:pass@server?autoconnect=1</tt>.
          <br/>
          These parameters are recognized:
          <ul>
            <li>
              <b>autoconnect=value</b> - A call to <ref type="api:class" link="rdbms.DBConnection#connect"/>
              may be ommitted. Just go ahead and when calling the first method which needs to connect
              (and log in), a connection will be established.<br/>
              Value is an integer of either 1 (on) or 0 (off). Default is 0 (off).
            </li>
            <li>
              <b>persistent=value</b> - Uses persistent database connections. These are explained in the
              <ref type="ext" link="http://php3.de/features.persistent-connections">PHP manual</ref>.<br/>
              Value is an integer of either 1 (on) or 0 (off). Default is 0 (off).
            </li>
            <li>
              <b>timeout=value</b> - Sets a connection timeout.<br/>
              Value is an integer specifying the number of seconds to wait before cancelling a connect/
              log on procedure. Default may vary between different RDBMS.
            </li>
            <li>
              <b>observer[key]=value</b> - Adds observers to the connection. For details on observers, see
              <ref link="tasks.rdbms#9">below</ref>.<br/>
              The key corresponds to an observer class, the value to a string passed to its constructor.
            </li>
          </ul>
        </text>
      </para>
      
      <para>
        <caption>Basics: Connecting to a database server and selecting data</caption>
        <text>
          Once we have fetched a specific database connection class, we can now invoke
          a number of methods on it.
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager');

  $conn= &DriverManager::getConnection(
    'sybase://user:pass@server/NICOTINE?autoconnect=1'
  );
  try(); {
    $news= $conn->select(
      'news_id, caption, author_id from news'
    );
  } if (catch('SQLException', $e)) {
    // [...handle error...]
    exit(-1);
  }

  // Dump all found records
  var_dump($news); ]]></code>
          The variable <tt>$news</tt> will now contain an array of all result sets.
          <box caption="Note:">
            Note the keyword <tt>select</tt> was omitted from the above query. This
            also applies to the <tt>update</tt>, <tt>insert</tt> and <tt>delete</tt>
            methods, but <b>not</b> to the generic <tt>query</tt> method (see the 
            following example).
          </box>
          
          The above method selects all resultsets into memory. This, of course, is 
          fine for resultsets containing a small number of rows. If you expect
          more results or if you want to iterate over the resultsets in a user-
          defined way, you will want to use the 
          <ref type="api:class" link="rdbms.DBConnection#query">query</ref> method:
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager');

  $conn= &DriverManager::getConnection(
    'sybase://user:pass@server/NICOTINE?autoconnect=1'
  );
  try(); {
    $news= &$conn->query(
      'select news_id, caption, author_id from news'
    );
  } if (catch('SQLException', $e)) {
    // [...handle error...]
    exit(-1);
  }

  // Iterate over resultset
  while ($record= $q->next()) {
    var_dump($record);
  } ]]></code>
          <box caption="Note:">
            Methods will throw exceptions for failed SQL queries, syntax errors,
            connection failure etc. All these exceptions are subclasses of 
            <ref type="api:class" link="rdbms.SQLException"/>, so to catch all possible
            errors, use it in the catch clause.
          </box>
        </text>
      </para>
      
      <para>
        <caption>Basics: Dynamically creating SQL queries</caption>
        <text>
          To "bind" parameters to an SQL query, the 
          <ref type="api:class" link="rdbms.DBConnection#query">query</ref>,
          <ref type="api:class" link="rdbms.DBConnection#select">select</ref>,
          <ref type="api:class" link="rdbms.DBConnection#update">update</ref>,
          <ref type="api:class" link="rdbms.DBConnection#delete">delete</ref> and
          <ref type="api:class" link="rdbms.DBConnection#insert">insert</ref>
          methods offer a <tt>printf</tt> style tokenizer and support
          varargs syntax. These take care of <tt>NULL</tt> and proper escaping
          for you.
          
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager');

  $conn= &DriverManager::getConnection(
    'sybase://user:pass@server/NICOTINE?autoconnect=1'
  );
  try(); {
    $news= &$conn->query('
      select
        news_id,
        caption,
        author_id
      from
        news
      where
        news_id= %d
      ',
      $news_id
    );
  } if (catch('SQLException', $e)) {
    // [...handle error...]
    exit(-1);
  }

  // Dump first row found
  var_dump($q->next()); ]]></code>
          As you can see in the above example, the variable <tt>$news_id</tt> is
          not casted to an integer or sanitized in any way. <b>There is no need
          to:</b> The tokenizer takes care of that for you.
          <br/>
          The following tokens are recognized:
          <ul>
            <li><b>%d</b> - the argument is represented as a numeric value</li>
            <li><b>%f</b> - the argument is represented as a decimal value</li>
            <li><b>%s</b> - the argument is represented as a string. Escaping is taken care of.</li>
            <li><b>%u</b> - the argument is a UNIX timestamp and converted to a date</li>
            <li><b>%c</b> - the argument is taken <b>as-is</b>. <b>Use with extreme care!</b></li>
          </ul>
          In addition to the format token, the following rules apply:
          <ul>
            <li>
              If the argument is <tt>NULL</tt> (not FALSE, or an empty string, <tt>=== NULL</tt>
              in PHP terms), the token is replaced by the (unquoted) word <b>NULL</b>.
            </li>
            <li>
              Passing an array will result in a comma separated list of replaced tokens.
              This is particularily useful when dealing with (SQL) <tt>in (...)</tt>.
            </li>
            <li>
              If the argument is an <ref type="api:class" link="util.Date"/> object,
              a rdbms-specific representation of the date is put in place of the token.
            </li>
            <li>
              If the argument is an object of any other class extending 
              <ref type="api:class" link="lang.Object"/>, its <tt>toString()</tt> method 
              is called, its output substitung the token.
            </li>
            <li>
              Argument numbering is also supported: Any token may be preceded by
              an offset (like in PHP's <tt>printf</tt>), as follows: <tt>%1$s</tt>
            </li>
          </ul>
          To return the tokenized SQL instead of sending it to the database engine, use 
          the <ref type="api:class" link="rdbms.DBConnection#prepare">prepare</ref> method.
        </text>
      </para>
      
      <para>
        <caption>Basics: Modifying data</caption>
        <text>
          Now that you've seen how to use the tokenizer, here's an example of how to insert
          data into a table.
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager');

  $conn= &DriverManager::getConnection(
    'sybase://user:pass@server/NICOTINE?autoconnect=1'
  );
  try(); {
    $conn->insert('
      into news (
        caption, author_id, body, extended, created_at
      ) values (
        %s, -- caption
        %d, -- author_id
        %s, -- body
        %s, -- extended
        %u  -- created_at
      )',
      $caption,
      $author_id,
      $body,
      $extended,
      time()
    );
    $news_id= $conn->identity();
  } if (catch('SQLException', $e)) {
    // [...handle error...]
    exit(-1);
  }

  // Output the identity value of the inserted data
  var_dump($news_id); ]]></code>
          Updating and deleting data works similar. The following example also shows how the tokenizer
          works for arrays.
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager');

  $conn= &DriverManager::getConnection(
    'sybase://user:pass@server/NICOTINE?autoconnect=1'
  );
  $author_ids= array(1, 2, 501);
  try(); {
    $updated= $conn->update('news set 
        caption= "[XP]" + caption 
      where 
        author_id in (%d)',
      $author_ids
    );
    $deleted= $conn->delete(
      'from news where caption like "Pörl%"'
    );
  } if (catch('SQLException', $e)) {
    // [...handle error...]
    exit(-1);
  }

  // Output the number of rows affected
  var_dump($updated, $deleted); ]]></code>
        </text>
      </para>
      
      <para>
        <caption>Transactions</caption>
        <text>
          To start a transaction, you can use the <ref type="api:class" link="rdbms.DBConnection#begin">begin</ref>
          method as follows:
          <code><![CDATA[  $transaction= &$conn->begin(new Transaction('create_author'); ]]></code>
          The <tt>begin</tt> method returns a <ref type="api:class" link="rdbms.Transaction"/> object which
          offers both <ref type="api:class" link="rdbms.Transaction#commit">commit</ref> and
          <ref type="api:class" link="rdbms.Transaction#rollback">rollback</ref> methods. A typical example
          would be the following:
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager');

  $conn= &DriverManager::getConnection(
    'sybase://user:pass@server/CAFFEINE?autoconnect=1'
  );
  try(); {
    $tran= &$conn->begin(new Transaction('create_author'));
    $conn->insert('
      into person (
        firstname, lastname, email, created_at
      ) values (
        %s, %s, %s, getdate()
      )',
      $firstname, 
      $lastname,
      $email
    );
    $conn->insert('
      into authors (
        person_id, username, password
      ) values (
        %d, %s, %s
      )',
      $conn->identity(),
      $username,
      crypt(uniqid(microtime()), chr(rand(65, 90)).'t')
    );
    $author_id= $conn->identity();
  } if (catch('SQLException', $e)) {
    // [...handle error...]
    $tran->rollback();
    exit(-1);
  }

  // Commit transaction and output identity value
  $tran->commit();
  var_dump($author_id); ]]></code>
          <box caption="Note:">
            Not all RDBMS' support transactions, and of those that do, not all support
            nested transactions. Be sure to read the manual pages of the RDBMS you are
            accessing.
          </box>
        </text>
      </para>
      
      <para>
        <caption>Advanced: The observer model</caption>
        <text>
          The observer model allows users to attach one or more observer objects to a 
          connection. An observer must implement the <ref type="api:class" link="rdbms.DBObserver"/>
          interface. A basic implementation could look like this (documentation omitted
          for brevity reasons):
          <code><![CDATA[  class MyObserver extends Object {

    function &instanceFor($arg) {
      static $inst= array();
      
      if (!isset($inst[$arg])) {
        $inst[$arg]= &new MyObserver();
      }
      return $inst[$arg];
    }
    
    function update(&$obs, $arg= NULL) {
      // [...do whatever...]
    }

  } implements (__FILE__, 'rdbms.DBObserver'); ]]></code>
          The observer's <tt>update</tt> method is called with two arguments:
          <ul>
            <li><b>obs</b> - contains the <ref type="api:class" link="rdbms.DBConnection"/> object the observer was registered to</li>
            <li><b>arg</b> - contains an <ref type="api:class" link="rdbms.DBEvent"/> object</li>
          </ul>
          Events are triggered in the following situations (event names printed in bold):
          <ul>
            <li>
              <b>connect</b> - a connection has been established<br/>
              The argument contains a boolean indicating whether reconnecting was requested.
            </li>
            <li>
              <b>query</b> - a query was issued.<br/>
              The argument contains the SQL sent to the database engine.
            </li>
            <li>
              <b>queryend</b> - the query function returned<br/>
              The argument contains the <ref type="api:class" link="rdbms.ResultSet"/> object.
            </li>
            <li>
              <b>select</b> - a select has been issued<br/>
              The argument contains the number of rows selected
            </li>
            <li>
              <b>identity</b> - an identity value has been retrieved<br/>
              The argument contains the identity value.
            </li>
          </ul>
          An example of such an observer can be found at <ref type="api:class" link="util.log.LogObserver"/>.
          <br/><br/>
          Obervers may be set up via DSN parameters or via an explicit call to 
          <ref type="api:class" link="rdbms.DBConnection#addObserver">addObserver</ref>. 
          The DSN variant is shown as an example here:<br/><br/>
          <tt>mysql://localhost/NEWS?observer[util.log.LogObserver]=default</tt>
        </text>
      </para>

      <para>
        <caption>Advanced: The connection manager</caption>
        <text>
          Often it is necessary to use database connections in various places within sourcecode.
          Imagine a database-driven web application such as a weblog, forum, or even
          a configuration suite (such as 1&amp;1's control panel). In either of the aforementioned 
          you will probably use the database connection in state classes (the ones reflecting a 
          page or a set of pages), in handlers (the classes handling submitted data), in helper 
          classes, and maybe in even more places.<br/>
          The singleton <ref type="api:class" link="rdbms.ConnectionManager"/> class releaves you 
          of the pain of always having to pass the database connection to all methods that (<i>may</i>) 
          need one.<br/>
          First, you'll need to set up the connection manager. You do this by either registering
          connections manually:
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.DriverManager', 'rdbms.ConnectionManager');

  // Set up the connection manager
  $cm= &ConnectionManager::getInstance();
  $cm->register(DriverManager::getConnection(
    'sybase://user:pass@server/CAFFEINE?autoconnect=1'
  ), 'caffeine'); ]]></code>
          ...or by using a configuration file:
          <code><![CDATA[  require('lang.base.php');
  uses('rdbms.ConnectionManager', 'util.Properties');

  // Set up the connection manager
  $cm= &ConnectionManager::getInstance();
  $cm->configure(new Properties('etc/rdbms.ini')); ]]></code>
          For the latter case, the property file <tt>etc/rdbms.ini</tt> needed will look 
          like this:
          <code><![CDATA[  ; Database configuration
  [caffeine]
  dsn="sybase://user:pass@server/CAFFEINE?autoconnect=1" ]]></code>
          <box caption="Note:">
            It is generally a good idea to use the property file approach: This way, no database
            credentials exist in the sourcecode.
          </box>
          The connection manager, once set up, is globally available; its instance can be 
          retrieved by using the <ref type="api:class" link="rdbms.ConnectionManager#getInstance"/>
          method.<br/><br/>
          For an example, have a look at the <ref type="api:class" link="net.xp_framework.db.caffeine.XPNews"/>
          class.
        </text>
        <advanced>
          <ref link="tasks.rdbms.op">Object persistence</ref>
        </advanced>
      </para>
    </content>
  </main>
</document>
