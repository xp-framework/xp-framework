<?xml version="1.0" encoding="iso-8859-1"?>
<document title="XP::Tasks::Overview">
  <main>
    <references>
      <ref link="about">An introduction</ref>
      <ref type="ext" link="http://php3.de/manual/en/features.commandline.php">Using PHP from the command line</ref>
      <ref type="ext" link="http://www.gnome.org/seegnome.html">See GTK/Gnome in action</ref>
      <ref type="ext" link="http://www.gimp.org/the_gimp_screenshots.html">GIMP screenshots</ref>
      <ref type="ext" link="http://gtk.php.net/resources.php">PHP-GTK: Resources</ref>
      <ref type="ext" link="http://www.eit.uni-kl.de/litz/lehre/seminar/seminar_ss_01/Meisner/sld012.htm">SOAP</ref>
      <ref type="ext" link="http://www.fh-wedel.de/~si/seminare/ws00/Ausarbeitung/6.soap/soap01.htm">SOAP</ref>
      <ref type="ext" link="http://de3.php.net/manual/en/history.php">History of PHP and related projects</ref>
    </references>
    <content>
      <title>Common Tasks</title>
      <editor>$Id$</editor>
      
      <para>
        <caption>How to complete common tasks with XP</caption>
        <text>
          This section will give an introduction to the basics of common tasks
          and how to accomplish them using the XP framework.
        </text>
      </para>
      
      <!-- cmd -->
      <para>
        <caption>Command-line tools</caption>
        <text>
          This is probably the most simple of all tasks, though not common to a large
          number of PHP users: PHP runs very well and stable as a command line tool,
          such as Perl, given even more power in the Release of PHP 4.3.0, where the
          CLI SAPI was introduced (see <ref type="ext" link="http://php3.de/manual/en/features.commandline.php">
          Using PHP from the command line</ref> for more information).
          <br/>
          As the XP framework's exception classes have no formatted error messages at all,
          you won't find yourself lost in tons of useless HTML pooring down your shell window if
          you print out stack traces (<ref type="api:class" link="lang.Exception#printStackTrace"/>) 
          or an object's string representation (<ref type="api:class" link="lang.Object#toString"/>).
          <br/>
          Command line tools differ from websites in various ways:
          <ul>
            <li>
              Usually, no HTML is printed. Text is formatted with linefeeds, tabs or spaces, 
              special characters or combination of such to draw lines, arrows or underline
              stuff.
            </li>
            <li>
              Input is read from STDIN, printed to STDOUT or STDERR.
            </li>
            <li>
              Variables (arguments) are passed via command line parameters, such as 
              <tt>-l</tt>, <tt>--debug</tt> or <tt>--prefix=/usr/local/</tt>.
            </li>
          </ul>
          This sounds like hacking in the first place, but actually, it's more like a religion. 
          Anyway, that's another story not to be told here, so let's have a start.
          <br/>
          <br/>
          Take, for example, this sample command line application:
          <code><![CDATA[  require('lang.base.php');
  uses('util.cmd.ParamString');

  $p= &new ParamString();
  if (2 != $p->count) {   // Always #options +1: values include script's name (#0)
    printf("Usage: %s <name>\n", $p->value(0));
    exit();
  }
  printf("Hello %s, how are you?\n", $p->value(1)); ]]></code>
          Calling this application from the command line as <tt>php -q hello.php</tt> 
          (assuming this script is called hello.php),
          it will simply print out <tt>Usage: hello.php &lt;name&gt;</tt> and exit. If a name
          is specified, e.g. <tt>php -q hello.php Timm</tt>, you will se <tt>Hello Timm, how
          are you?</tt> appear on your shell window. Simple enough?
          <br/>
          <br/>
          Now, we'll include support for a help option as seen in most tools (that is, supply
          a <tt>-?</tt> or <tt>--help</tt> in the parameter list of a command line tool and it
          will say how you're supposed to use it). Again, this is simple - modify line no. five
          of the above example to read:
          <code><![CDATA[  if (2 != $p->count || $p->exists('help', '?')) { ]]></code>
          As soon as a user calls <tt>php -q hello.php -?</tt> or <tt>php -q hello.php --help</tt>,
          the tool will now also print out the usage information. Have a look at the 
          <ref type="api:class" link="util.cmd.ParamString"/> class for more information.
          <br/>
          <br/>
          There is actually not much more to know about the basics of command line scripts
          in relation to the XP framework. There are however, some advanced topics
          on more complex tasks and how they're wrapped into classes and objects.
        </text>
        <advanced>
          <ref link="tasks.cmd.stdio">Using the standard I/O streams</ref>
          <ref link="tasks.cmd.cron">Cronjobs</ref>
          <ref link="tasks.cmd.interactive">Interactive tools</ref>
        </advanced>
      </para>
      
      <!-- web -->
      <para>
        <caption>Web sites</caption>
        <text>
          <!-- <ref type="api:class" link="org.apache.HttpScriptlet"/> -->
          Web sites is what PHP was made for. In his 
          <ref type="ext" link="http://groups.google.com/groups?selm=3r7pgp%24aa1%40ionews.io.org">announce mail</ref>
          in June of 1995, Rasmus Lerdorf marketed PHP (then called "Personal Home Page Tools"
          as the ideal tool to develop guest books and handle form requests.
          <br/>
          PHP (now called "PHP Hypertext Preprocessor") has since then become much more than
          a "set of cgi scripts". Of course, it is still formidable at handling HTTP request, be
          it as an Apache module or as a CGI. Recently, Yahoo! - being one of the world's busiest
          sites - <ref type="ext" link="http://news.com.com/2100-1023-963937.html?tag=lh">has decided 
          to migrate its scripts to PHP</ref>.
          <br/>
          <br/>
          The XP framework introduces an API called "scriptlets". Scriptlets are the counterpart to 
          Java's Servlets - as one might have guessed from their name. Scriptlets are not a 1:1 
          implementation of Servlets though one might find a lot of similarities!
          <br/>
          Let's have a look at a simple scriptlet:
          <code><![CDATA[  uses('org.apache.HttpScriplet');

  class HelloScriptlet extends HttpScriplet {

    function doGet(&$request, &$response) {
      // [... Sample abridged for brevity ...]
      if (empty($request->getParam('name'))) {
        $response->write('
          <form action="'.basename($request->getEnvValue('SCRIPT_URI')).'">
            Enter your name here: <input type="text" name="name"/>
            <input type="submit"/>
          </form>
        ');
        return;
      }
      $response->write('Hello '.$request->getParam('name'));
    }
  } ]]></code>
          Of course, this seems, not much more elaborate than embedding PHP
          into HTML. Plus, it's probably more complicated to use all the object-oriented
          "bloat" at first.
          <br/>
          <br/>
          Of course, writing out HTML (with maybe some variable here or there) is easy,
          but you will find that after a while of doing so, it turns out this tactic
          is rather counter-productive. Imagine you want to completely redesign your website:
          Changing the navigation from a frameset to tables, put some links at top, make
          each page contain a link to produce a printer-friendly version of itself.
          <br/>
          You will inadvertedly find yourself going through tons of sourcecode "knowing"
          to much about but effectively producing the same HTML over and over and will
          maybe go from coding HTML to using utility functions (such as a function that
          will return a table from an array) - and probably end up using one of the
          numerous template engines available. Wondering why there is no such thing in
          the XP framework?
          <br/>
          <br/>
          The answer is quite easy: Template engines are always built on top of PHP, trying
          to emulate what PHP is actually really good at: Being a template engine! 
          As if PHP wasn't easy enough, they add complex proprietary syntactic constructs 
          making web site data unportable. A whole bunch of parsing and tokenizing is done
          to accomplish loops, if, then, else, case, whatever-constructs which raises
          the question - if you need reparsing, why not use <tt>eval()</tt>?
          <br/>
          <br/>
          It was decided to stick to standards here and use XML together with XSL
          to keep data portable, taking advantage of the fact that XSL transformer
          implementations are usually written in C or in C++ for performance reasons,
          not having to worry about the fact that content editors and designers might
          need to learn a whole new language. Also, more and more data is decided
          on being represented in XML: This way, you can include RDF news feeds,
          Office documents and SOAP replies directly into your website, given the
          correct templates.
          <br/>
          Have a look at the advanced topics section for details.
        </text>
        <advanced>
          <ref link="tasks.web.xml">Using XML/XSL to seperate code from design</ref>
          <ref link="tasks.web.rdf">RDF news feeds</ref>
        </advanced>
      </para>

      <!-- soap -->
      <para>
        <caption>SOAP clients/servers</caption>
        <text>
          SOAP ("Simple Object Access Protocol") seems quite abstract in the beginning - with all
          of the abbreviatons accompanying its <ref type="ext" link="http://www.w3.org/TR/SOAP/">specification</ref>:
          WSDL, UDDI, XMLSchema, ... once comprehended, it's actually quite simple to understand
          (though not quite so simple to implement). No need to worry, it's already happened: XP offers a 
          SOAP client and -server API: One of the goals of the XP framework was to seamlessly integrate 
          XML and SOAP into easy-to-use APIs. One of the results of this effort is that the
          creation and utilizations of webservices via SOAP requires only a couple of lines of code.
          <br/>
          <br/>
          
          Use a script like this to call a SOAP service as a client. It will print out the results
          from the Method <tt>Action::Method('Paramater')</tt> on <tt>http://endpoint.of/the/soapservice</tt>:
          <code><![CDATA[  require('lang.base.php');
  uses(
    'xml.soap.transport.SOAPHTTPTransport',
    'xml.soap.SOAPClient'
  );
  
  $s= &new SOAPClient(
    new SOAPHTTPTransport('http://endpoint.of/the/soapservice'),
    'Action',
    'Method'
  );
  
  // Call SOAP service
  try(); {
    $return= $s->call('Parameter');
  } if (catch('Exception', $e)) {
    $e->printStackTrace();
    exit;
  }
  
  var_dump($return);]]></code>
          (See also advanced topics: Utilizing the Google API)<br/>
          <br/>
          So, now let's play it the other way aroung: The following snippet shows how to write up a 
          SOAP service utilizing Apache as webserver:
          <code><![CDATA[  require('lang.base.php');
  uses('xml.soap.rpc.SoapRpcRouter');
  
  $s= &new SoapRpcRouter(new ClassLoader('info.binford6100.webservices'));
  try(); {
    $s->init();
    $response= &$s->process();
  } if (catch('HttpScriptletException', $e)) {
  
    // Retreive standard "Internal Server Error"-Document
    // Remember: Faults are already handled by SoapRpcRouter - this
    // will take care of GET, HEAD or any other request except for POST
    $response= &$e->getResponse(); 
  }
  $response->sendHeaders();
  $response->sendContent();

  $s->finalize();]]></code>
          Place this code in the document root of the SOAP endpoint virtualhost (e.g., 
          <tt>/usr/local/apache/htdocs/index.php</tt>, check out the handler classes to 
          the correct skeleton path and that's basically it: You're ready to serve.
        </text>
        <advanced>
          <ref link="tasks.soap.google">Utilizing the Google API</ref>
          <ref link="tasks.soap.wsdl">Generating proxy classes from WSDL</ref>
        </advanced>
      </para>
      
      <!-- gui -->
      <para>
        <caption>GUI applications</caption>
        <text>
          <ref type="ext" link="http://gtk.org/">GTK</ref> stands for "Gimp Tool Kit" and 
          was originally developed to serve as a widget set for this open source 
          graphics program. GTK is available for Unix systems as well as for Windows, 
          Mac OS X and even BeOS.
          <br/>
          GTK has language bindings for a number of different programming languages,
          including, as of May 2001, PHP (see the <ref type="ext" link="http://gtk.php.net/">
          GTK-PHP website</ref> for details). In PHP, every widget is represented by a
          wrapper class, so coding is already object-oriented. The XP framework adds
          a number of utility classes to make it even easier to create GUI applications.
          <br/>
          <br/>
          The ease of use of the base class for all GTK applications written
          using the XP framework is probably best demonstrated by this piece of sample
          code:
          <code><![CDATA[  require('lang.base.php');
  uses('gui.gtk.GTKApplication');

  $app= &new GTKApplication('Hello World');
  $app->init();
  $app->run();
  $app->done(); ]]></code>
          API Docs: <ref type="api:class" link="gui.gtk.GTKApplication"/><br/>
          <br/>
          The sample shown above has absolutely no functionality so far. It will,
          when executed, show a window which can be resized, moved, maximized,
          minimized and closed, but contains no elements such as buttons, images.
          <box caption="Note:">
            Always calling init, run, done may seem like overhead. There is
            a utility script in <tt>util/bin</tt> called <tt>gtkphp</tt> which will
            automagically take over this part for you. Simply create a class as shown 
            above, but without the require and without the last four lines. Then call
            <tt>gtkphp /path/to/your/app/MyApp.class.php</tt> and enjoy.
          </box>
          In the following examples, it is assumed you either paste the glue text
          above and below your classes or resent to using the gtkphp script.
          <br/>
          <br/>
          Extending GTKApplication is the way to add functionality to your application.
          <code><![CDATA[  class MyApp extends GTKApplication {
  
    function init() {
      parent::init();
      $button= &new GTKButton('OK');
      $button->show();
      $button->connect('clicked', array(&$this, 'done'));
      $this->window->add($button);
    }
  
  }]]></code>
          This application will now have a button labeled OK, which, when pressed,
          will quit the application.
        </text>
        <advanced>
          <ref link="tasks.gui.glade">Using Glade to build interfaces</ref>
          <ref link="tasks.gui.widgets">Additional widgets</ref>
          <ref link="tasks.gui.i18n">Internationalized GUIs</ref>
          <ref link="tasks.gui.html">Embedding HTML</ref>
        </advanced>
      </para>
      
      <!-- server -->
      <para>
        <caption>Stand-Alone servers</caption>
        <text>
          <!-- <ref type="api:class" link="peer.ServerSocket"/> -->
          Ut eu leo nec nunc aliquet aliquam. Proin sed sapien. Praesent orci. Integer pharetra laoreet libero. Mauris eu urna. Maecenas interdum tellus varius tellus. Curabitur et enim ut libero interdum fringilla. Aenean gravida. Morbi vel massa. Curabitur commodo vehicula libero. Phasellus posuere lacus vestibulum orci. Aliquam rutrum risus et sapien. Aliquam elementum.
        </text>
        <advanced>
          <ref link="tasks.server.forking">Multiprocess servers</ref>
        </advanced>
      </para>
    </content>
  </main>
</document>
