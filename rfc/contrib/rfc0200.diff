Index: skeleton/xml/Node.class.php
===================================================================
--- skeleton/xml/Node.class.php	(revision 14616)
+++ skeleton/xml/Node.class.php	(working copy)
@@ -6,8 +6,10 @@
  */
 
   uses(
+    'xml.Element',
     'xml.PCData',
     'xml.CData',
+    'xml.Text',
     'xml.XMLFormatException'
   );
   
@@ -23,14 +25,13 @@
    * @see   xp://xml.Tree#addChild
    * @test  xp://net.xp_framework.unittest.xml.NodeTest
    */
-  class Node extends Object {
+  class Node extends Object implements Element {
     const
       XML_ILLEGAL_CHARS   = XML_ILLEGAL_CHARS;
 
     public 
       $name         = '',
       $attribute    = array(),
-      $content      = NULL,
       $children     = array();
 
     /**
@@ -45,12 +46,18 @@
      * @param   string name
      * @param   string content default NULL
      * @param   array<string, string> attribute default array() attributes
-     * @throws  lang.IllegalArgumentException
+     * @throws  xml.XMLFormatException
      */
     public function __construct($name, $content= NULL, $attribute= array()) {
       $this->name= $name;
       $this->attribute= $attribute;
-      $this->setContent($content);
+      if (NULL !== $content) {
+        if ($content instanceof Element) {
+          $this->children= array($content);
+        } else if ('' !== $content) {
+          $this->children= array(new Text($content));
+        }
+      }
     }
 
     /**
@@ -131,31 +138,40 @@
     /**
      * Set content
      *
+     * @deprecated  Use addChild(new Text(...)) instead
      * @param   string content
      * @throws  xml.XMLFormatException in case content contains illegal characters
      */
     public function setContent($content) {
-
-      // Scan the given string for illegal characters.
-      if (is_string($content)) {  
-        if (strlen($content) > ($p= strcspn($content, XML_ILLEGAL_CHARS))) {
-          throw new XMLFormatException(
-            'Content contains illegal character at position '.$p. ' / chr('.ord($content{$p}).')'
-          );
-        }
-      }
-      
-      $this->content= $content;
+      $this->children[]= new Text($content);
     }
     
     /**
      * Get content (all CDATA)
      *
+     * @deprecated  Use textContent() instead
      * @return  string content
      */
     public function getContent() {
-      return $this->content;
+      return $this->textContent();
     }
+    
+    /**
+     * Get content
+     *
+     * @return  string content
+     */
+    public function textContent() {
+      $c= '';
+      foreach ($this->children as $child) {
+        if ($child instanceof Text) {
+          $c.= $child->getContent();
+        } else if ($child instanceof self) {
+          $c.= $child->textContent();
+        }
+      }
+      return $c;
+    }
 
     /**
      * Set an attribute
@@ -234,31 +250,16 @@
     public function getSource($indent= INDENT_WRAPPED, $encoding= 'iso-8859-1', $inset= '') {
       $xml= $inset.'<'.$this->name;
       $conv= 'iso-8859-1' != $encoding;
-      
-      if ('string' == ($type= gettype($this->content))) {
+
+      if (1 === sizeof($this->children) && $this->children[0] instanceof Text) {
+        $children= array();
         $content= $conv
-          ? iconv('iso-8859-1', $encoding, htmlspecialchars($this->content))
-          : htmlspecialchars($this->content)
+          ? iconv('iso-8859-1', $encoding, htmlspecialchars($this->children[0]->getContent()))
+          : htmlspecialchars($this->children[0]->getContent())
         ;
-      } else if ('float' == $type) {
-        $content= ($this->content - floor($this->content) == 0)
-          ? number_format($this->content, 0, NULL, NULL)
-          : $this->content
-        ;
-      } else if ($this->content instanceof PCData) {
-        $content= $conv
-          ? iconv('iso-8859-1', $encoding, $this->content->pcdata)
-          : $this->content->pcdata
-        ;
-      } else if ($this->content instanceof CData) {
-        $content= '<![CDATA['.str_replace(']]>', ']]]]><![CDATA[>', $conv
-          ? iconv('iso-8859-1', $encoding, $this->content->cdata)
-          : $this->content->cdata
-        ).']]>';
-      } else if ($this->content instanceof String) {
-        $content= htmlspecialchars($this->content->getBytes($encoding));
       } else {
-        $content= $this->content; 
+        $children= $this->children;
+        $content= NULL; 
       }
       
       if (INDENT_NONE === $indent) {
@@ -268,8 +269,12 @@
             : $value
           ).'"';
         }
+
+        // No content and no children => close tag
+        if (NULL === $content && !$children) return $xml.'/>';
+        
         $xml.= '>'.$content;
-        foreach ($this->children as $child) {
+        foreach ($children as $child) {
           $xml.= $child->getSource($indent, $encoding, $inset);
         }
         return $xml.'</'.$this->name.'>';
@@ -286,16 +291,16 @@
         }
 
         // No content and no children => close tag
-        if (0 == strlen($content)) {
-          if (!$this->children) return $xml."/>\n";
+        if (NULL === $content) {
+          if (!$children) return $xml."/>\n";
           $xml.= '>';
         } else {
           $xml.= '>'.($indent ? "\n  ".$inset.$content : trim($content));
         }
 
-        if ($this->children) {
+        if ($children) {
           $xml.= ($indent ? '' : $inset)."\n";
-          foreach ($this->children as $child) {
+          foreach ($children as $child) {
             $xml.= $child->getSource($indent, $encoding, $inset.'  ');
           }
           $xml= ($indent ? substr($xml, 0, -1) : $xml).$inset;
@@ -307,25 +312,52 @@
     /**
      * Add a child node
      *
-     * @param   xml.Node child
-     * @return  xml.Node added child
+     * @param   xml.Element child
+     * @return  xml.Element added child
      * @throws  lang.IllegalArgumentException in case the given argument is not a Node
      */
-    public function addChild(Node $child) {
+    public function addChild(Element $child) {
       $this->children[]= $child;
       return $child;
     }
+    
+    /**
+     * Returns whether another object is equal to this node
+     *
+     * @param   lang.Generic cmp
+     * @return  bool
+     */
+    public function equals($cmp) {
+      return $cmp instanceof self && $this->getSource(INDENT_NONE) === $cmp->getSource(INDENT_NONE);
+    }
 
     /**
      * Add a child node and return this node
      *
-     * @param   xml.Node child
+     * @param   xml.Element child
      * @return  xml.Node this
      * @throws  lang.IllegalArgumentException in case the given argument is not a Node
      */
-    public function withChild(Node $child) {
+    public function withChild(Element $child) {
       $this->addChild($child);
       return $this;
     }
+
+    /**
+     * Creates a string representation of this object
+     *
+     * @return  string
+     */
+    public function toString() {
+      $a= '';
+      foreach ($this->attribute as $name => $value) {
+        $a.= ' @'.$name.'= '.xp::stringOf($value);
+      }
+      $s= $this->getClassName().'('.$this->name.$a.") {\n";
+      foreach ($this->children as $child) {
+        $s.= '  '.str_replace("\n", "\n  ", xp::stringOf($child))."\n";
+      }
+      return $s.'}';
+    }
   }
 ?>
Index: skeleton/xml/dom/Document.class.php
===================================================================
--- skeleton/xml/dom/Document.class.php	(revision 14616)
+++ skeleton/xml/dom/Document.class.php	(working copy)
@@ -33,15 +33,18 @@
      */
     protected function _getElementsByTagName($node, $tagname, $max= -1) {
       $r= array();
-      foreach (array_keys($node->children) as $key) {
-        if ($tagname == $node->children[$key]->getName()) {
-          $r[]= $node->children[$key];
+      foreach ($node->children as $child) {
+        if (!$child instanceof Node) continue;
+        
+        if ($tagname === $child->getName()) {
+          $r[]= $child;
           if ($max > 0 && sizeof($r) >= $max) return $r;
         }
-        if (!empty($node->children[$key]->children)) {
+        if (!empty($child->children)) {
           $r= array_merge($r, $this->_getElementsByTagName(
-            $node->children[$key], 
-            $tagname
+            $child, 
+            $tagname, 
+            $max- sizeof($r)
           ));
         }
       }
@@ -59,20 +62,19 @@
      */
     protected function _getElementsByAttribute($node, $attribute, $name, $max) {
       $r= array();
-      foreach (array_keys($node->children) as $key) {
-        if (
-          ($node->children[$key]->hasAttribute($attribute)) &&
-          ($name == $node->children[$key]->getAttribute($attribute))
-        ) {
-          $r[]= $node->children[$key];
+      foreach ($node->children as $child) {
+        if (!$child instanceof Node) continue;
+
+        if ($child->hasAttribute($attribute) && ($name === $child->getAttribute($attribute))) {
+          $r[]= $child;
           if ($max > 0 && sizeof($r) >= $max) return $r;
         }
-        if (!empty($node->children[$key]->children)) {
+        if (!empty($child->children)) {
           $r= array_merge($r, $this->_getElementsByAttribute(
-            $node->children[$key], 
+            $child, 
             $attribute, 
             $name,
-            $max
+            $max- sizeof($r)
           ));
         }
       }
Index: skeleton/xml/Element.class.php
===================================================================
--- skeleton/xml/Element.class.php	(revision 0)
+++ skeleton/xml/Element.class.php	(revision 0)
@@ -0,0 +1,25 @@
+<?php
+/* This class is part of the XP framework
+ *
+ * $Id$ 
+ */
+
+  /**
+   * Represents an element in an XML tree. An element will be one of the 
+   * following:
+   * <ul>
+   *   <li>A node (optionally with attributes)</li>
+   *   <li>Text</li>
+   *   <li>CDATA</li>
+   *   <li>A comment</li>
+   *   <li>A processing instruction</li>
+   *   <li>A document fragment</li>
+   * </ul>
+   *
+   * @see   xp://xml.Tree#addChild
+   * @see   xp://xml.Node#addChild
+   */
+  interface Element {
+    
+  }
+?>

Property changes on: skeleton/xml/Element.class.php
___________________________________________________________________
Added: svn:keywords
   + Id

Index: skeleton/xml/PCData.class.php
===================================================================
--- skeleton/xml/PCData.class.php	(revision 14616)
+++ skeleton/xml/PCData.class.php	(working copy)
@@ -4,6 +4,8 @@
  * $Id$
  */
 
+  uses('xml.Element');
+
   /**
    * PCData allows to insert literal XML into a nodes contents.
    *
@@ -24,11 +26,11 @@
    * Passing incorrect XML to this class will result in a not-
    * wellformed output document.
    *
+   * @deprecated  Use xml.Fragment instead
    * @purpose  Wrapper
    */
-  class PCData extends Object {
-    public
-      $pcdata= '';
+  class PCData extends Object implements Element {
+    public $pcdata= '';
       
     /**
      * Constructor
@@ -37,7 +39,22 @@
      */
     public function __construct($pcdata) {
       $this->pcdata= $pcdata;
-      
     }
+
+    /**
+     * Retrieve XML representation
+     *
+     * @param   int indent default INDENT_WRAPPED
+     * @param   string encoding default 'iso-8859-1'
+     * @param   string inset default ''
+     * @return  string XML
+     */
+    public function getSource($indent= INDENT_WRAPPED, $encoding= 'iso-8859-1', $inset= '') {
+      $conv= 'iso-8859-1' != $encoding;
+      return $conv
+        ? iconv('iso-8859-1', $encoding, $this->pcdata)
+        : $this->pcdata
+      ;
+    }
   }
 ?>
Index: skeleton/xml/meta/Marshaller.class.php
===================================================================
--- skeleton/xml/meta/Marshaller.class.php	(revision 14616)
+++ skeleton/xml/meta/Marshaller.class.php	(working copy)
@@ -63,7 +63,7 @@
         
         // Node content
         if ('.' == $element) {
-          $node->setContent($method->invoke($instance));
+          $node->addChild(new Text($method->invoke($instance)));
           continue;
         }
         
Index: skeleton/xml/Tree.class.php
===================================================================
--- skeleton/xml/Tree.class.php	(revision 14616)
+++ skeleton/xml/Tree.class.php	(working copy)
@@ -7,7 +7,9 @@
   uses(
     'xml.parser.XMLParser',
     'xml.Node',
-    'xml.parser.ParserCallback'
+    'xml.parser.TreeParser',
+    'xml.parser.StringInputSource',
+    'xml.parser.FileInputSource'
   );
  
   /**
@@ -18,16 +20,11 @@
    * @see      xp://xml.parser.XMLParser
    * @purpose  Tree
    */
-  class Tree extends Object implements ParserCallback {
+  class Tree extends Object {
     public 
       $root     = NULL,
       $nodeType = NULL;
 
-    public
-      $_cnt     = NULL,
-      $_cdata   = NULL,
-      $_objs    = NULL;
-
     protected 
       $version  = '1.0',
       $encoding = 'iso-8859-1';
@@ -112,23 +109,14 @@
      *   $tree= Tree::fromString('<document>...</document>');
      * </code>
      *
+     * @deprecated Use xml.parser.TreeParser instead
      * @param   string string
      * @param   string c default __CLASS__ class name
      * @return  xml.Tree
      * @throws  xml.XMLFormatException in case of a parser error
      */
     public static function fromString($string, $c= __CLASS__) {
-      $parser= new XMLParser();
-      $tree= new $c();
-
-      $parser->setCallback($tree);
-      $parser->parse($string, 1);
-
-      // Fetch actual encoding from parser
-      $tree->setEncoding($parser->getEncoding());
-
-      delete($parser);
-      return $tree;
+      return create(new TreeParser(new XPClass($c)))->parse(new StringInputSource($string));
     }
     
     /**
@@ -138,6 +126,7 @@
      *   $tree= Tree::fromFile(new File('foo.xml'));
      * </code>
      *
+     * @deprecated Use xml.parser.TreeParser instead
      * @param   io.File file
      * @param   string c default __CLASS__ class name
      * @return  xml.Tree
@@ -145,89 +134,22 @@
      * @throws  io.IOException in case reading the file fails
      */ 
     public static function fromFile($file, $c= __CLASS__) {
-      $parser= new XMLParser();
-      $tree= new $c();
-      
-      $parser->setCallback($tree);
-      $file->open(FILE_MODE_READ);
-      $string= $file->read($file->size());
-      $file->close();
-      $parser->parse($string);
-
-      // Fetch actual encoding from parser
-      $tree->setEncoding($parser->getEncoding());
-
-      delete($parser);
-      return $tree;
+      return create(new TreeParser(new XPClass($c)))->parse(new FileInputSource($file));
     }
-    
-    /**
-     * Callback function for XMLParser
-     *
-     * @param   resource parser
-     * @param   string name
-     * @param   string attrs
-     * @see     xp://xml.parser.XMLParser
-     */
-    public function onStartElement($parser, $name, $attrs) {
-      $this->_cdata= '';
 
-      $element= new $this->nodeType($name, NULL, $attrs);
-      if (!isset($this->_cnt)) {
-        $this->root= $element;
-        $this->_objs[1]= $element;
-        $this->_cnt= 1;
-      } else {
-        $this->_cnt++;
-        $this->_objs[$this->_cnt]= $element;
-      }
-    }
-   
     /**
-     * Callback function for XMLParser
+     * Creates a string representation of this object
      *
-     * @param   resource parser
-     * @param   string name
-     * @see     xp://xml.parser.XMLParser
+     * @return  string
      */
-    public function onEndElement($parser, $name) {
-      if ($this->_cnt > 1) {
-        $node= $this->_objs[$this->_cnt];
-        $node->content= $this->_cdata;
-        $parent= $this->_objs[$this->_cnt- 1];
-        $parent->addChild($node);
-        $this->_cdata= '';
-      } else {
-        $this->root->content= $this->_cdata;
-        $this->_cdata= '';
-      }
-      $this->_cnt--;
-      
-      // Clean up upon last element
-      if (0 === $this->_cnt) {
-        unset($this->_cnt, $this->_cdata, $this->_objs);
-      }
+    public function toString() {
+      return sprintf(
+        "%s(version=%s encoding=%s)@{\n  %s\n}",
+        $this->getClassName(),
+        $this->version,
+        $this->encoding,
+        str_replace("\n", "\n  ", xp::stringOf($this->root))
+      );
     }
-
-    /**
-     * Callback function for XMLParser
-     *
-     * @param   resource parser
-     * @param   string cdata
-     * @see     xp://xml.parser.XMLParser
-     */
-    public function onCData($parser, $cdata) {
-      $this->_cdata.= $cdata;
-    }
-
-    /**
-     * Callback function for XMLParser
-     *
-     * @param   resource parser
-     * @param   string data
-     * @see     xp://xml.parser.XMLParser
-     */
-    public function onDefault($parser, $data) {
-    }
   } 
 ?>
Index: skeleton/xml/parser/TreeParser.class.php
===================================================================
--- skeleton/xml/parser/TreeParser.class.php	(revision 0)
+++ skeleton/xml/parser/TreeParser.class.php	(revision 0)
@@ -0,0 +1,132 @@
+<?php
+/* This class is part of the XP framework
+ *
+ * $Id$ 
+ */
+
+  uses(
+    'xml.parser.XMLParser', 
+    'xml.Tree', 
+    'xml.Node', 
+    'xml.Node', 
+    'xml.Comment',
+    'xml.ProcessingInstruction'
+  );
+
+  /**
+   * Parses input sources into XML
+   * 
+   * Usage example:
+   * <code>
+   *   $t= create(new TreeParser())->parse(new FileInputStream(...));
+   *
+   *   // Work with the tree object, e.g.
+   *   $t->root->addChild(new Node('document'));
+   * </code>
+   *
+   * @see     xp://xml.Tree
+   * @test    xp://net.xp_framework.unittest.xml.TreeParserTest
+   */
+  class TreeParser extends XMLParser {
+    private $stack= array();
+    
+    /**
+     * Construct a new tree parser
+     *
+     * @param   lang.XPClass class
+     */
+    public function __construct(XPClass $class= NULL, $encoding= 'iso-8859-1') {
+      parent::__construct($encoding);
+      if (NULL === $class) {
+        $this->class= XPClass::forName('xml.Tree');
+      } else {
+        $this->class= $class;
+      }
+    }
+    
+    /**
+     * Parse XML data
+     *
+     * @param   xml.parser.InputSource data
+     * @param   string source default NULL optional source identifier, will show up in exception
+     * @return  xml.Tree
+     * @throws  xml.XMLFormatException in case the data could not be parsed
+     */
+    public function parse($data, $source= NULL) {
+      with ($tree= $this->class->newInstance()); {
+        $this->callback= $this;
+        $this->stack= array(0 => NULL);
+        parent::parse($data, $source);
+        $tree->root= $this->stack[0];
+        $tree->setEncoding($this->encoding);
+        return $tree;
+      }
+    }
+
+    /**
+     * Callback function for XMLParser
+     *
+     * @param   resource parser
+     * @param   string name
+     * @param   string attrs
+     * @see     xp://xml.parser.XMLParser
+     */
+    public function onStartElement($parser, $name, $attrs) {
+      array_unshift($this->stack, new Node($name, NULL, $attrs));
+    }
+   
+    /**
+     * Callback function for XMLParser
+     *
+     * @param   resource parser
+     * @param   string name
+     * @see     xp://xml.parser.XMLParser
+     */
+    public function onEndElement($parser, $name) {
+      $c= array_shift($this->stack);
+      if ($this->stack[0]) {
+        $this->stack[0]->addChild($c);
+      } else {
+        $this->stack[0]= $c;
+      }
+    }
+
+    /**
+     * Callback function for XMLParser
+     *
+     * @param   resource parser
+     * @param   string cdata
+     * @see     xp://xml.parser.XMLParser
+     */
+    public function onCData($parser, $cdata) {
+
+      // Ignore tokens consisting entirely of whitespace
+      if (strlen($cdata) !== strspn($cdata, " \r\n\t")) {
+        $this->stack[0]->addChild(new Text($cdata));
+      }
+    }
+
+    /**
+     * Callback function for XMLParser
+     *
+     * @param   resource parser
+     * @param   string data
+     * @see     xp://xml.parser.XMLParser
+     */
+    public function onDefault($parser, $data) {
+      $this->stack[0]->addChild(new CommentNode(substr($data, 4, -3)));   // Trim "<!--" and "-->"
+    }
+
+    /**
+     * Callback function for XMLParser
+     *
+     * @param   resource parser
+     * @param   string name
+     * @param   string content
+     * @see     xp://xml.parser.XMLParser
+     */
+    public function onProcessing($parser, $name, $content) {
+      $this->stack[0]->addChild(new ProcessingInstructionNode($name, $content));
+    }
+  }
+?>

Property changes on: skeleton/xml/parser/TreeParser.class.php
___________________________________________________________________
Added: svn:keywords
   + Id

Index: skeleton/xml/parser/XMLParser.class.php
===================================================================
--- skeleton/xml/parser/XMLParser.class.php	(revision 14616)
+++ skeleton/xml/parser/XMLParser.class.php	(working copy)
@@ -35,9 +35,9 @@
     /**
      * Constructor
      *
-     * @param   string encoding default 'ISO-8859-1'
+     * @param   string encoding default 'iso-8859-1'
      */
-    public function __construct($encoding= 'ISO-8859-1') {
+    public function __construct($encoding= 'iso-8859-1') {
       $this->encoding= $encoding;
     }
 
@@ -110,6 +110,7 @@
           xml_set_element_handler($parser, 'onStartElement', 'onEndElement');
           xml_set_character_data_handler($parser, 'onCData');
           xml_set_default_handler($parser, 'onDefault');
+          method_exists($this->callback, 'onProcessing') && xml_set_processing_instruction_handler($parser, 'onProcessing');
         }
         
         // Parse streams while reading data
Index: skeleton/xml/Comment.class.php
===================================================================
--- skeleton/xml/Comment.class.php	(revision 0)
+++ skeleton/xml/Comment.class.php	(revision 0)
@@ -0,0 +1,79 @@
+<?php
+/* This class is part of the XP framework
+ *
+ * $Id$
+ *
+ */
+
+  uses(
+    'xml.Element',
+    'xml.XMLFormatException'
+  );
+
+  /**
+   * Represents a comment
+   *
+   */
+  class Comment extends Object implements Element {
+    protected $content = NULL;
+
+    /**
+     * Constructor
+     *
+     * <code>
+     *   $n= new Comment('Hello World');
+     * </code>
+     *
+     * @param   string content default NULL
+     * @throws  xml.XMLFormatException
+     */
+    public function __construct($content= NULL) {
+      $this->setContent($content);
+    }
+
+    /**
+     * Set content
+     *
+     * @param   string content
+     * @throws  xml.XMLFormatException in case content contains illegal characters
+     */
+    public function setContent($content) {
+
+      // Scan the given string for illegal characters.
+      if (is_string($content)) {  
+        if (strlen($content) > ($p= strcspn($content, XML_ILLEGAL_CHARS))) {
+          throw new XMLFormatException(
+            'Content contains illegal character at position '.$p. ' / chr('.ord($content{$p}).')'
+          );
+        }
+      }
+      
+      $this->content= $content;
+    }
+    
+    /**
+     * Get content (all CDATA)
+     *
+     * @return  string content
+     */
+    public function getContent() {
+      return $this->content;
+    }
+    
+    /**
+     * Retrieve XML representation
+     *
+     * @param   int indent default INDENT_WRAPPED
+     * @param   string encoding default 'iso-8859-1'
+     * @param   string inset default ''
+     * @return  string XML
+     */
+    public function getSource($indent= INDENT_WRAPPED, $encoding= 'iso-8859-1', $inset= '') {
+      $conv= 'iso-8859-1' != $encoding;
+      return '<!--'.($conv
+        ? iconv('iso-8859-1', $encoding, htmlspecialchars($this->content))
+        : htmlspecialchars($this->content)
+      ).'-->';
+    }
+  }
+?>

Property changes on: skeleton/xml/Comment.class.php
___________________________________________________________________
Added: svn:keywords
   + Id

Index: skeleton/xml/Fragment.class.php
===================================================================
--- skeleton/xml/Fragment.class.php	(revision 0)
+++ skeleton/xml/Fragment.class.php	(revision 0)
@@ -0,0 +1,68 @@
+<?php
+/* This class is part of the XP framework
+ *
+ * $Id$
+ */
+
+  uses('xml.Element');
+
+  /**
+   * Fragment allows to insert literal XML into a node's contents.
+   *
+   * Example:
+   * <code>
+   *   $tree= new Tree();
+   *   $tree->addChild(new Node('text', new Fragment('Hello<br/>World')));
+   * </code>
+   *
+   * The output will then be:
+   * <pre>
+   *   <document>
+   *     <text>Hello<br/>World</text>
+   *   </document>
+   * </pre>
+   *
+   * Note: The XML passed to Fragment's constructor is not validated!
+   * Passing incorrect XML to this class will result in a not-
+   * wellformed output document.
+   */
+  class Fragment extends Object implements Element {
+    public $pcdata= '';
+      
+    /**
+     * Constructor
+     *
+     * @param   string pcdata
+     */
+    public function __construct($pcdata) {
+      $this->pcdata= $pcdata;
+    }
+    
+    /**
+     * Append XML and return this fragment
+     *
+     * @param   string pcdata
+     * @return  xml.Fragment this
+     */
+    public function append($pcdata) {
+      $this->pcdata.= $pcdata;
+      return $this;
+    }
+
+    /**
+     * Retrieve XML representation
+     *
+     * @param   int indent default INDENT_WRAPPED
+     * @param   string encoding default 'iso-8859-1'
+     * @param   string inset default ''
+     * @return  string XML
+     */
+    public function getSource($indent= INDENT_WRAPPED, $encoding= 'iso-8859-1', $inset= '') {
+      $conv= 'iso-8859-1' != $encoding;
+      return $conv
+        ? iconv('iso-8859-1', $encoding, $this->pcdata)
+        : $this->pcdata
+      ;
+    }
+  }
+?>

Property changes on: skeleton/xml/Fragment.class.php
___________________________________________________________________
Added: svn:keywords
   + Id

Index: skeleton/xml/CData.class.php
===================================================================
--- skeleton/xml/CData.class.php	(revision 14616)
+++ skeleton/xml/CData.class.php	(working copy)
@@ -4,6 +4,8 @@
  * $Id$
  */
 
+  uses('xml.Element');
+
   /**
    * CData allows to insert a CDATA section:
    *
@@ -22,9 +24,8 @@
    *
    * @purpose  Wrapper
    */
-  class CData extends Object {
-    public
-      $cdata= '';
+  class CData extends Object implements Element {
+    public $cdata= '';
       
     /**
      * Constructor
@@ -34,5 +35,21 @@
     public function __construct($cdata) {
       $this->cdata= $cdata;
     }
+
+    /**
+     * Retrieve XML representation
+     *
+     * @param   int indent default INDENT_WRAPPED
+     * @param   string encoding default 'iso-8859-1'
+     * @param   string inset default ''
+     * @return  string XML
+     */
+    public function getSource($indent= INDENT_WRAPPED, $encoding= 'iso-8859-1', $inset= '') {
+      $conv= 'iso-8859-1' != $encoding;
+      return '<![CDATA['.str_replace(']]>', ']]]]><![CDATA[>', $conv
+        ? iconv('iso-8859-1', $encoding, $this->cdata)
+        : $this->cdata
+      ).']]>';
+    }
   }
 ?>
Index: skeleton/xml/ProcessingInstruction.class.php
===================================================================
--- skeleton/xml/ProcessingInstruction.class.php	(revision 0)
+++ skeleton/xml/ProcessingInstruction.class.php	(revision 0)
@@ -0,0 +1,100 @@
+<?php
+/* This class is part of the XP framework
+ *
+ * $Id$
+ *
+ */
+
+  uses(
+    'xml.Element',
+    'xml.XMLFormatException'
+  );
+
+  /**
+   * Represents a processing instruction
+   *
+   */
+  class ProcessingInstruction extends Object implements Element {
+    protected $name = NULL;
+    protected $content = NULL;
+
+    /**
+     * Constructor
+     *
+     * <code>
+     *   $n= new ProcessingInstruction('php', 'echo "Hello";');
+     * </code>
+     *
+     * @param   string name
+     * @param   string content default NULL
+     * @throws  xml.XMLFormatException
+     */
+    public function __construct($name, $content= NULL) {
+      $this->name= $name;
+      $this->setContent($content);
+    }
+
+    /**
+     * Sets name
+     *
+     * @param   string name
+     */
+    public function setName($name) {
+      $this->name= $name;
+    }
+    
+    /**
+     * Gets name
+     *
+     * @return  string
+     */
+    public function getName() {
+      return $this->name;
+    }
+
+    /**
+     * Set content
+     *
+     * @param   string content
+     * @throws  xml.XMLFormatException in case content contains illegal characters
+     */
+    public function setContent($content) {
+
+      // Scan the given string for illegal characters.
+      if (is_string($content)) {  
+        if (strlen($content) > ($p= strcspn($content, XML_ILLEGAL_CHARS))) {
+          throw new XMLFormatException(
+            'Content contains illegal character at position '.$p. ' / chr('.ord($content{$p}).')'
+          );
+        }
+      }
+      
+      $this->content= $content;
+    }
+    
+    /**
+     * Get content (all CDATA)
+     *
+     * @return  string content
+     */
+    public function getContent() {
+      return $this->content;
+    }
+    
+    /**
+     * Retrieve XML representation
+     *
+     * @param   int indent default INDENT_WRAPPED
+     * @param   string encoding default 'iso-8859-1'
+     * @param   string inset default ''
+     * @return  string XML
+     */
+    public function getSource($indent= INDENT_WRAPPED, $encoding= 'iso-8859-1', $inset= '') {
+      $conv= 'iso-8859-1' != $encoding;
+      return '<?'.$this->name.' '.($conv
+        ? iconv('iso-8859-1', $encoding, htmlspecialchars($this->content))
+        : htmlspecialchars($this->content)
+      ).'?>';
+    }
+  }
+?>

Property changes on: skeleton/xml/ProcessingInstruction.class.php
___________________________________________________________________
Added: svn:keywords
   + Id

Index: skeleton/xml/Text.class.php
===================================================================
--- skeleton/xml/Text.class.php	(revision 0)
+++ skeleton/xml/Text.class.php	(revision 0)
@@ -0,0 +1,94 @@
+<?php
+/* This class is part of the XP framework
+ *
+ * $Id$
+ *
+ */
+
+  uses(
+    'xml.Element',
+    'xml.XMLFormatException'
+  );
+
+  /**
+   * Represents a text element
+   *
+   */
+  class Text extends Object implements Element {
+    protected $content = NULL;
+
+    /**
+     * Constructor
+     *
+     * <code>
+     *   $n= new Text('Hello World');
+     * </code>
+     *
+     * @param   string content default NULL
+     * @throws  xml.XMLFormatException
+     */
+    public function __construct($content= NULL) {
+      $this->setContent($content);
+    }
+
+    /**
+     * Set content
+     *
+     * @param   string content
+     * @throws  xml.XMLFormatException in case content contains illegal characters
+     */
+    public function setContent($content) {
+
+      // Scan the given string for illegal characters.
+      if (is_string($content)) {  
+        if (strlen($content) > ($p= strcspn($content, XML_ILLEGAL_CHARS))) {
+          throw new XMLFormatException(
+            'Content contains illegal character at position '.$p. ' / chr('.ord($content{$p}).')'
+          );
+        }
+        $this->content= $content;
+      } else if (is_float($content)) {
+        $this->content= ($content - floor($content) == 0)
+          ? number_format($content, 0, '', '')
+          : $content
+        ;
+      } else {
+        $this->content= $content;
+      }
+    }
+    
+    /**
+     * Get content (all CDATA)
+     *
+     * @return  string content
+     */
+    public function getContent() {
+      return $this->content;
+    }
+    
+    /**
+     * Retrieve XML representation
+     *
+     * @param   int indent default INDENT_WRAPPED
+     * @param   string encoding default 'iso-8859-1'
+     * @param   string inset default ''
+     * @return  string XML
+     */
+    public function getSource($indent= INDENT_WRAPPED, $encoding= 'iso-8859-1', $inset= '') {
+      $conv= 'iso-8859-1' != $encoding;
+      return htmlspecialchars($conv
+        ? iconv('iso-8859-1', $encoding, $this->content)
+        : $this->content
+      );
+    }
+    
+    /**
+     * Creates a string representation of this object
+     *
+     * @return  string
+     */
+    public function toString() {
+      return $this->getClassName().'<"'.addcslashes($this->content, "\0..\17").'">';
+    }
+  }
+?>

Property changes on: skeleton/xml/Text.class.php
___________________________________________________________________
Added: svn:keywords
   + Id

Index: skeleton/webservices/soap/xp/XPSoapHeaderElement.class.php
===================================================================
--- skeleton/webservices/soap/xp/XPSoapHeaderElement.class.php	(revision 14616)
+++ skeleton/webservices/soap/xp/XPSoapHeaderElement.class.php	(working copy)
@@ -4,7 +4,7 @@
  * $Id$ 
  */
 
-  uses('webservices.soap.xp.XPSoapNode', 'webservices.soap.xp.XPSoapHeader');
+  uses('xml.Node', 'webservices.soap.xp.XPSoapHeader');
 
   /**
    * Represent a SOAP header element.
@@ -53,7 +53,7 @@
       if ($this->actor) $attr[$ns[XMLNS_SOAPENV].':actor']= $this->actor;
       if ($this->encodingStyle) $attr[$ns[XMLNS_SOAPENV].':encodingStyle']= $this->encodingStyle;
       
-      return new XPSoapNode($this->name, $this->value, $attr);
+      return new Node($this->name, $this->value, $attr);
     }
 
     /**
Index: skeleton/webservices/soap/xp/XPSoapMessage.class.php
===================================================================
--- skeleton/webservices/soap/xp/XPSoapMessage.class.php	(revision 14616)
+++ skeleton/webservices/soap/xp/XPSoapMessage.class.php	(working copy)
@@ -9,7 +9,6 @@
     'xml.Node',
     'lang.Collection',
     'webservices.soap.CommonSoapFault',
-    'webservices.soap.xp.XPSoapNode',
     'webservices.soap.xp.XPSoapHeaderElement',
     'webservices.soap.xp.XPSoapMapping',
     'scriptlet.rpc.AbstractRpcMessage'
@@ -68,16 +67,6 @@
       );
 
     /**
-     * Constructor
-     *
-     * @param   string rootName default 'document'
-     */
-    public function __construct($rootName= 'document') {
-      parent::__construct($rootName);
-      $this->nodeType= xp::reflect('xml.soap.xp.XPSoapNode');
-    }
-
-    /**
      * Create a message
      *
      * @param   string action
@@ -153,21 +142,156 @@
     public function setMapping($mapping) {
       $this->mapping= $mapping;
     }
+
+    /**
+     * Get type name by content
+     *
+     * @param   var content
+     * @return  string typename, e.g. "xsd:string"
+     */
+    protected function _typeName($content) {
+      static $tmap= array(      // Mapping PHP-typename => SOAP-typename
+        'double'        => 'float',
+        'integer'       => 'int'
+      );
+      
+      $t= gettype($content);
+      if (isset($tmap[$t])) $t= $tmap[$t];
+      return 'xsd:'.$t;
+    }
     
     /**
+     * Format content
+     *
+     * @param   var content
+     * @return  var content, formatted, if necessary
+     */
+    protected function _contentFormat($content) {
+      if (is_bool($content)) {
+        return $content ? 'true' : 'false';
+      }
+      return $content;
+    }
+
+    /**
+     * Marshaller
+     *
+     * @param   xml.Node child
+     * @param   var value
+     * @param   webservices.soap.xp.XPSoapMapping mapping
+     */
+    protected function marshall($child, $value) {
+      static $ns= 0;
+      
+      if (is_scalar($value)) {          // Scalar
+        $child->attribute['xsi:type']= $this->_typeName($value);
+        $child->setContent($this->_contentFormat($value));
+        return;
+      }
+      
+      if (is_null($value)) {            // NULL
+        $child->attribute['xsi:nil']= 'true';
+        return;
+      }
+      
+      if (is_array($value)) {           // Array
+        if (is_numeric(key($value))) {
+          $child->attribute['xsi:type']= 'SOAP-ENC:Array';
+          $child->attribute['SOAP-ENC:arrayType']= 'xsd:anyType['.sizeof($value).']';
+        } else {
+          $child->attribute['xsi:type']= 'xsd:struct';
+          if (empty($value)) $child->attribute['xsi:nil']= 'true';
+        }
+        $this->_recurse($child, $value);
+        return;
+      }
+
+      if ($value instanceof Parameter) {  // Named parameter
+        $child->name= $value->name;
+        $this->marshall($child, $value->value);
+        return;
+      }
+      
+      if ($value instanceof Date) {       // Date
+        $value= new SOAPDateTime($value->getHandle());
+        // Fallthrough intended
+      }
+      
+      if ($value instanceof Hashmap) {    // Hashmap
+        $value= new SOAPHashMap($value->_hash);
+        // Fallthrough intended
+      }
+      
+      if ($value instanceof SoapType) {   // Special SoapTypes
+        if (FALSE !== ($name= $value->getItemName())) $child->name= $name;
+        $this->marshall($child, $value->toString());
+        
+        // Specified type
+        if (NULL !== ($t= $value->getType())) $child->attribute['xsi:type']= $t;
+        
+        // A node
+        if (isset($value->item)) {
+          $child->attribute= $value->item->attribute;
+          $child->children= array_merge($child->children, $value->item->children);
+        }
+        return;
+      }
+      
+      if (($value instanceof Generic) && NULL !== ($qname= $this->mapping->qnameFor($value->getClass()))) {
+        $ns++;
+        $child->attribute['xmlns:ns'.$ns]= $qname->namespace;
+        $child->attribute['xsi:type']= 'ns'.$ns.':'.$qname->localpart;
+        
+        $this->_recurse($child, get_object_vars($value));
+        return;
+      }
+      
+      if ($value instanceof Collection) { // XP collection
+        $child->attribute['xsi:type']= 'SOAP-ENC:Array';
+        $child->attribute['xmlns:xp']= 'http://xp-framework.net/xmlns/xp';
+        $child->attribute['SOAP-ENC:arrayType']= 'xp:'.$value->getElementClassName().'['.$value->size().']';
+        $this->_recurse($child, $value->values());
+        return;
+      }
+      
+      if ($value instanceof Generic) {     // XP objects
+        $child->attribute['xmlns:xp']= 'http://xp-framework.net/xmlns/xp';
+        $child->attribute['xsi:type']= 'xp:'.$value->getClassName();
+        $this->_recurse($child, get_object_vars($value));
+        return;
+      }
+      
+      if (is_object($value)) {          // Any other object, e.g. "stdClass"
+        $ns++;
+        $child->attribute['xmlns:ns'.$ns]= 'http://xp-framework.net/xmlns/php';
+        $child->attribute['xsi:type']= 'ns'.$ns.':'.get_class($value);
+        $this->_recurse($child, get_object_vars($value));
+        return;        
+      }
+      
+      // Any other type is simply ignored
+    }
+
+    /**
+     * Recurse an array
+     *
+     * @param   xml.Node e element to add array to
+     * @param   array a
+     */
+    protected function _recurse($e, $a) {
+      foreach (array_keys($a) as $field) {
+        if ('_' == $field{0}) continue;
+        $this->marshall($e->addChild(new Node(is_numeric($field) ? 'item' : $field)), $a[$field]);
+      }
+    }
+   
+    /**
      * Set data
      *
      * @param   array arr
      */
     public function setData($arr) {
-      $node= XPSoapNode::fromArray($arr, 'item', $this->mapping);
-      $node->namespace= $this->namespace;
-      if (empty($node->children)) return;
-      
-      // Copy all of node's children to root element
-      foreach (array_keys($node->children) as $i) {
-        $this->body->children[0]->addChild($node->children[$i]);
-      }
+      $this->_recurse($this->body->children[0], $arr);
     }
 
     /**
@@ -178,6 +302,65 @@
     public function getContentType() { return 'text/xml'; }    
 
     /**
+     * Get content in iso-8859-1 encoding (the default).
+     *
+     * @param   xml.Node child
+     * @return  var data
+     */
+    protected function childContent($child) {
+      $encoding= $this->getEncoding();
+      $ret= $child->textContent();
+      @list($ns, $t)= explode(':', @$child->attribute[$this->namespaces[XMLNS_XSI].':type']);
+      
+      switch (strtolower($t)) {
+        case 'base64':
+        case 'base64binary':
+          
+          return new SOAPBase64Binary($ret, $encoded= TRUE);
+          break;
+        
+        case 'hexbinary':
+          return new SOAPHexBinary($ret, $encoded= TRUE);
+          break;
+        
+        case 'boolean':
+          return (
+            (0 == strncasecmp('true', $ret, 4)) || 
+            (0 == strncasecmp('1', $ret, 1))
+          ) ? TRUE : FALSE;
+         
+        case 'long':
+        case 'int':
+          $t= 'integer';
+          break;
+          
+        case 'decimal':  
+        case 'float':
+        case 'double':
+          $t= 'double';
+          break;
+          
+        case 'date':
+        case 'datetime':    // ISO 8601: http://www.w3.org/TR/xmlschema-2/#ISO8601 http://www.w3.org/TR/xmlschema-2/#dateTime
+          return new Date($ret);
+          break;
+          
+        default:
+          $t= 'string';
+      }
+      
+      // Decode if necessary
+      switch (strtolower($encoding)) {
+        case 'utf-8': $ret= utf8_decode($ret); break;
+      }
+
+      // Set type
+      settype($ret, $t);
+
+      return $ret; 
+    }
+
+    /**
      * Deserialize a single node
      *
      * @param   xml.Node child
@@ -290,9 +473,9 @@
           // <item>
           if (empty($child->children)) break;
           foreach ($child->children as $item) {
-            $key= $item->children[0]->getContent($this->getEncoding(), $this->namespaces);
+            $key= $this->childContent($item->children[0]);
             $result[$key]= ((empty($item->children[1]->children) && !isset($item->children[1]->attribute['href']))
-              ? $item->children[1]->getContent($this->getEncoding(), $this->namespaces)
+              ? $this->childContent($item->children[1])
               : $this->unmarshall($item->children[1], 'MAP')
             );
           }
@@ -305,7 +488,18 @@
           break;
           
         default:
-          if (!empty($child->children)) {
+          $s= sizeof($child->children);
+          if (0 === $s) {
+          
+            // Empty node, e.g. <null xsi:nil="true"/>
+            $result= NULL;
+          } else if (1 === $s && $child->children[0] instanceof Text) {
+          
+            // Text-only contents, e.g. <item xsi:type="xsd:int">5</item>
+            $result= $this->childContent($child);
+          } else {
+          
+            // Complex node, e.g. <array><string>one</string><string>two</string></array>
             if ($this->namespaces[XMLNS_XSD] == $regs[1]) {
               $result= $this->_recurseData($child, TRUE, 'STRUCT');
               break;
@@ -347,8 +541,6 @@
             }
             break;
           }
-
-          $result= $child->getContent($this->getEncoding(), $this->namespaces);
       }
 
       return $result;
@@ -416,12 +608,12 @@
      * @param   var detail default NULL
      */    
     public function setFault($faultcode, $faultstring, $faultactor= NULL, $detail= NULL) {
-      $this->root->children[0]->children[0]= XPSoapNode::fromObject(new CommonSoapFault(
+      $this->marshal($this->root->children[0]->children[0], new CommonSoapFault(
         $faultcode,
         $faultstring,
         $faultactor,
         $detail
-      ), 'SOAP-ENV:Fault', $this->mapping);
+      ));
       $this->root->children[0]->children[0]->name= 'SOAP-ENV:Fault';
     }
 
Index: skeleton/webservices/soap/xp/XPSoapNode.class.php
===================================================================
--- skeleton/webservices/soap/xp/XPSoapNode.class.php	(revision 14616)
+++ skeleton/webservices/soap/xp/XPSoapNode.class.php	(working copy)
@@ -1,271 +0,0 @@
-<?php
-/* This class is part of the XP framework
- *
- * $Id$ 
- */
-
-  uses(
-    'xml.Node',
-    'webservices.soap.types.SOAPBase64Binary',
-    'webservices.soap.types.SOAPHexBinary',
-    'webservices.soap.types.SOAPDateTime',
-    'webservices.soap.types.SOAPHashMap'
-  );
-
-  /**
-   * SOAP Node
-   *
-   * @see   xp://xml.Node
-   */
-  class XPSoapNode extends Node {
-    public 
-      $namespace= 'ctl';
-    
-    /**
-     * Get type name by content
-     *
-     * @param   var content
-     * @return  string typename, e.g. "xsd:string"
-     */
-    protected function _typeName($content) {
-      static $tmap= array(      // Mapping PHP-typename => SOAP-typename
-        'double'        => 'float',
-        'integer'       => 'int'
-      );
-      
-      $t= gettype($content);
-      if (isset($tmap[$t])) $t= $tmap[$t];
-      return 'xsd:'.$t;
-    }
-    
-    /**
-     * Format content
-     *
-     * @param   var content
-     * @return  var content, formatted, if necessary
-     */
-    protected function _contentFormat($content) {
-      if (is_bool($content)) {
-        return $content ? 'true' : 'false';
-      }
-      return $content;
-    }
-    
-    /**
-     * Get content in iso-8859-1 encoding (the default).
-     *
-     * @param   string encoding
-     * @param   var namespaces
-     * @return  var data
-     */
-    public function getContent($encoding= NULL, $namespaces= NULL) {
-      $ret= $this->content;
-      @list($ns, $t)= explode(':', @$this->attribute[$namespaces[XMLNS_XSI].':type']);
-      
-      switch (strtolower($t)) {
-        case 'base64':
-        case 'base64binary':
-          
-          return new SOAPBase64Binary($ret, $encoded= TRUE);
-          break;
-        
-        case 'hexbinary':
-          return new SOAPHexBinary($ret, $encoded= TRUE);
-          break;
-        
-        case 'boolean':
-          return (
-            (0 == strncasecmp('true', $ret, 4)) || 
-            (0 == strncasecmp('1', $ret, 1))
-          ) ? TRUE : FALSE;
-         
-        case 'long':
-        case 'int':
-          $t= 'integer';
-          break;
-          
-        case 'decimal':  
-        case 'float':
-        case 'double':
-          $t= 'double';
-          break;
-          
-        case 'date':
-        case 'datetime':    // ISO 8601: http://www.w3.org/TR/xmlschema-2/#ISO8601 http://www.w3.org/TR/xmlschema-2/#dateTime
-          return new Date($ret);
-          break;
-          
-        default:
-          $t= 'string';
-      }
-      
-      // Decode if necessary
-      switch (strtolower($encoding)) {
-        case 'utf-8': $ret= utf8_decode($ret); break;
-      }
-
-      // Set type
-      settype($ret, $t);
-
-      return $ret; 
-    }
-    
-    /**
-     * Marshaller
-     *
-     * @param   webservices.soap.xp.XPSoapNode child
-     * @param   var value
-     * @param   webservices.soap.xp.XPSoapMapping mapping
-     */
-    protected function _marshall($child, $value, $mapping) {
-      static $ns= 0;
-      
-      if (is_scalar($value)) {          // Scalar
-        $child->attribute['xsi:type']= $child->_typeName($value);
-        $child->setContent($child->_contentFormat($value));
-        return;
-      }
-      
-      if (is_null($value)) {            // NULL
-        $child->attribute['xsi:nil']= 'true';
-        return;
-      }
-      
-      if (is_array($value)) {           // Array
-        if (is_numeric(key($value))) {
-          $child->attribute['xsi:type']= 'SOAP-ENC:Array';
-          $child->attribute['SOAP-ENC:arrayType']= 'xsd:anyType['.sizeof($value).']';
-        } else {
-          $child->attribute['xsi:type']= 'xsd:struct';
-          if (empty($value)) $child->attribute['xsi:nil']= 'true';
-        }
-        $this->_recurse($child, $value, $mapping);
-        return;
-      }
-
-      if ($value instanceof Parameter) {  // Named parameter
-        $child->name= $value->name;
-        $this->_marshall($child, $value->value, $mapping);
-        return;
-      }
-      
-      if ($value instanceof Date) {       // Date
-        $value= new SOAPDateTime($value->getHandle());
-        // Fallthrough intended
-      }
-      
-      if ($value instanceof Hashmap) {    // Hashmap
-        $value= new SOAPHashMap($value->_hash);
-        // Fallthrough intended
-      }
-      
-      if ($value instanceof SoapType) {   // Special SoapTypes
-        if (FALSE !== ($name= $value->getItemName())) $child->name= $name;
-        $this->_marshall($child, $value->toString(), $mapping);
-        
-        // Specified type
-        if (NULL !== ($t= $value->getType())) $child->attribute['xsi:type']= $t;
-        
-        // A node
-        if (isset($value->item)) {
-          $child->attribute= $value->item->attribute;
-          $child->children= array_merge($child->children, $value->item->children);
-        }
-        return;
-      }
-      
-      if (($value instanceof Generic) && NULL !== ($qname= $mapping->qnameFor($value->getClass()))) {
-        $ns++;
-        $child->attribute['xmlns:ns'.$ns]= $qname->namespace;
-        $child->attribute['xsi:type']= 'ns'.$ns.':'.$qname->localpart;
-        
-        $this->_recurse($child, get_object_vars($value), $mapping);
-        return;
-      }
-      
-      if ($value instanceof Collection) { // XP collection
-        $child->attribute['xsi:type']= 'SOAP-ENC:Array';
-        $child->attribute['xmlns:xp']= 'http://xp-framework.net/xmlns/xp';
-        $child->attribute['SOAP-ENC:arrayType']= 'xp:'.$value->getElementClassName().'['.$value->size().']';
-        $this->_recurse($child, $value->values(), $mapping);
-        return;
-      }
-      
-      if ($value instanceof Generic) {     // XP objects
-        $child->attribute['xmlns:xp']= 'http://xp-framework.net/xmlns/xp';
-        $child->attribute['xsi:type']= 'xp:'.$value->getClassName();
-        $this->_recurse($child, get_object_vars($value), $mapping);
-        return;
-      }
-      
-      if (is_object($value)) {          // Any other object, e.g. "stdClass"
-        $ns++;
-        $child->attribute['xmlns:ns'.$ns]= 'http://xp-framework.net/xmlns/php';
-        $child->attribute['xsi:type']= 'ns'.$ns.':'.get_class($value);
-        $this->_recurse($child, get_object_vars($value), $mapping);
-        return;        
-      }
-      
-      // Any other type is simply ignored
-    }
-    
-    /**
-     * Recurse an array
-     *
-     * @param   xml.Node e element to add array to
-     * @param   array a
-     * @param   webservices.soap.xp.XPSoapMapping mapping
-     */
-    protected function _recurse($e, $a, $mapping) {
-      foreach (array_keys($a) as $field) {
-        if ('_' == $field{0}) continue;
-        $this->_marshall(
-          $e->addChild(new self(is_numeric($field) ? 'item' : $field)),
-          $a[$field],
-          $mapping
-        );
-      }
-    }
-    
-    /**
-     * Create a node from an array
-     *
-     * Usage example:
-     * <code>
-     *   $n= Node::fromArray($array, 'elements');
-     * </code>
-     *
-     * @param   array arr
-     * @param   string name default 'array'
-     * @param   webservices.soap.xp.XPSoapMapping mapping
-     * @return  xml.Node
-     */
-    public static function fromArray($arr, $name= 'array', $mapping= NULL) {
-      $n= new self($name);
-      $n->_recurse($n, $arr, $mapping);
-      return $n;  
-    }
-    
-    /**
-     * Create a node from an object. Will use class name as node name
-     * if the optional argument name is omitted.
-     *
-     * Usage example:
-     * <code>
-     *   $n= Node::fromObject($object);
-     * </code>
-     *
-     * @param   lang.Generic obj
-     * @param   string name default NULL
-     * @param   webservices.soap.xp.XPSoapMapping mapping
-     * @return  xml.Node
-     */
-    public static function fromObject($obj, $name= NULL, $mapping= NULL) {
-      return self::fromArray(
-        get_object_vars($obj), 
-        (NULL === $name) ? get_class($obj) : $name,
-        $mapping
-      );
-    }
-  }
-?>
Index: ports/classes/net/xp_framework/unittest/xml/NodeTest.class.php
===================================================================
--- ports/classes/net/xp_framework/unittest/xml/NodeTest.class.php	(revision 14616)
+++ ports/classes/net/xp_framework/unittest/xml/NodeTest.class.php	(working copy)
@@ -208,6 +208,54 @@
     }
 
     /**
+     * Tests a node with numbers
+     *
+     */
+    #[@test]
+    public function sourceOfNodeWithZero() {
+      $this->assertEquals(
+        '<number>0</number>', 
+        $this->sourceOf(new Node('number', 0))
+      );
+    }
+
+    /**
+     * Tests a node with numbers
+     *
+     */
+    #[@test]
+    public function sourceOfNodeWithNegativeNumber() {
+      $this->assertEquals(
+        '<number>-1</number>', 
+        $this->sourceOf(new Node('number', -1))
+      );
+    }
+
+    /**
+     * Tests a node with numbers
+     *
+     */
+    #[@test]
+    public function sourceOfNodeWithHugeDoubleNumber() {
+      $this->assertEquals(
+        '<number>214748364821474</number>', 
+        $this->sourceOf(new Node('number', (double)214748364821474))
+      );
+    }
+
+    /**
+     * Tests a node with numbers
+     *
+     */
+    #[@test]
+    public function sourceOfNodeWithHugeNegativeDoubleNumber() {
+      $this->assertEquals(
+        '<number>-214748364821474</number>', 
+        $this->sourceOf(new Node('number', (double)-214748364821474))
+      );
+    }
+
+    /**
      * Tests a node with CDATA content. 
      *
      */
@@ -215,7 +263,7 @@
     public function sourceOfNodeWithCData() {
       $this->assertEquals(
         '<text><![CDATA[Special characters: <>"\'&]]></text>', 
-        $this->sourceOf(new Node('text', new CData('Special characters: <>"\'&')))
+        $this->sourceOf(new Node('text', new CData('Special characters: <>"\'&')), INDENT_NONE)
       );
     }
 
@@ -227,7 +275,7 @@
     public function sourceOfNodeWithPCData() {
       $this->assertEquals(
         '<text>A <a href="http://xp-framework.net/">link</a> to click on</text>', 
-        $this->sourceOf(new Node('text', new PCData('A <a href="http://xp-framework.net/">link</a> to click on')))
+        $this->sourceOf(new Node('text', new PCData('A <a href="http://xp-framework.net/">link</a> to click on')), INDENT_NONE)
       );
     }
     
Index: ports/classes/net/xp_framework/unittest/xml/TreeTest.class.php
===================================================================
--- ports/classes/net/xp_framework/unittest/xml/TreeTest.class.php	(revision 14616)
+++ ports/classes/net/xp_framework/unittest/xml/TreeTest.class.php	(working copy)
@@ -72,12 +72,10 @@
      */
     #[@test]
     public function fromString() {
-      $t= Tree::fromString('
-        <c:config xmlns:c="http://example.com/cfg/1.0">
-          <attribute name="key">value</attribute>
-        </c:config>
-      ');
-      
+      $t= Tree::fromString(
+        '<c:config xmlns:c="http://example.com/cfg/1.0"><attribute name="key">value</attribute></c:config>'
+      );
+
       with ($r= $t->root); {
         $this->assertEquals('c:config', $r->getName());
         $this->assertTrue($r->hasAttribute('xmlns:c'));
@@ -89,7 +87,7 @@
         $this->assertEquals('attribute', $c->name);
         $this->assertTrue($c->hasAttribute('name'));
         $this->assertEquals('key', $c->getAttribute('name'));
-        $this->assertEquals(0, sizeof($c->children));
+        $this->assertEquals(1, sizeof($c->children));
         $this->assertEquals('value', $c->getContent());
       }
     }
@@ -104,7 +102,7 @@
         <document><node>Some umlauts: </node></document>
       ');
       
-      $this->assertEquals('ISO-8859-1', $tree->getEncoding());
+      $this->assertEquals('iso-8859-1', $tree->getEncoding());
       $this->assertEquals(1, sizeof($tree->root->children));
       $this->assertEquals('document', $tree->root->getName());
       $this->assertEquals('Some umlauts: ', $tree->root->children[0]->getContent());
@@ -120,7 +118,7 @@
         <document><node>Some umlauts: </node></document>
       ');
       
-      $this->assertEquals('ISO-8859-1', $tree->getEncoding());
+      $this->assertEquals('iso-8859-1', $tree->getEncoding());
       $this->assertEquals(1, sizeof($tree->root->children));
       $this->assertEquals('document', $tree->root->getName());
       $this->assertEquals('Some umlauts: ', $tree->root->children[0]->getContent());
@@ -133,7 +131,7 @@
     #[@test]
     public function singleElement() {
       $tree= Tree::fromString('<document empty="false">Content</document>');
-      $this->assertEquals(0, sizeof($tree->root->children));
+      $this->assertEquals(1, sizeof($tree->root->children));
       $this->assertEquals('Content', $tree->root->getContent());
       $this->assertEquals('false', $tree->root->getAttribute('empty'));
     }
@@ -166,10 +164,10 @@
      */
     #[@test]
     public function iso88591Encoding() {
-      $t= create(new Tree('unicode'))->withEncoding('ISO-8859-1');
+      $t= create(new Tree('unicode'))->withEncoding('iso-8859-1');
       $t->root->setContent('Hllo');
 
-      $this->assertEquals('<?xml version="1.0" encoding="ISO-8859-1"?>', $t->getDeclaration());
+      $this->assertEquals('<?xml version="1.0" encoding="iso-8859-1"?>', $t->getDeclaration());
       $this->assertEquals('<unicode>Hllo</unicode>', $this->sourceOf($t));
     }
 
@@ -192,10 +190,10 @@
      */
     #[@test]
     public function iso88591EncodingWithIso88591StringObject() {
-      $t= create(new Tree('unicode'))->withEncoding('ISO-8859-1');
+      $t= create(new Tree('unicode'))->withEncoding('iso-8859-1');
       $t->root->setContent(new String('Hllo', 'iso-8859-1'));
 
-      $this->assertEquals('<?xml version="1.0" encoding="ISO-8859-1"?>', $t->getDeclaration());
+      $this->assertEquals('<?xml version="1.0" encoding="iso-8859-1"?>', $t->getDeclaration());
       $this->assertEquals('<unicode>Hllo</unicode>', $this->sourceOf($t));
     }
 
@@ -218,10 +216,10 @@
      */
     #[@test]
     public function iso88591EncodingWithUtf8StringObject() {
-      $t= create(new Tree('unicode'))->withEncoding('ISO-8859-1');
+      $t= create(new Tree('unicode'))->withEncoding('iso-8859-1');
       $t->root->setContent(new String('Hllo', 'UTF-8'));
 
-      $this->assertEquals('<?xml version="1.0" encoding="ISO-8859-1"?>', $t->getDeclaration());
+      $this->assertEquals('<?xml version="1.0" encoding="iso-8859-1"?>', $t->getDeclaration());
       $this->assertEquals('<unicode>Hllo</unicode>', $this->sourceOf($t));
     }
 
Index: ports/classes/net/xp_framework/unittest/xml/DocumentTest.class.php
===================================================================
--- ports/classes/net/xp_framework/unittest/xml/DocumentTest.class.php	(revision 14616)
+++ ports/classes/net/xp_framework/unittest/xml/DocumentTest.class.php	(working copy)
@@ -28,7 +28,10 @@
       </list>');
       
       $this->assertEquals(
-        $dom->getDocumentElement()->children,
+        array(
+          new Node('person', 'Timm', array('id' => 1549)),
+          new Node('person', 'Alex', array('id' => 1552))
+        ),
         $dom->getElementsByTagName('person')
       );
     }
@@ -45,7 +48,7 @@
       </list>');
       
       $this->assertEquals(
-        $dom->getDocumentElement()->children[0],
+        new Node('person', 'Timm', array('id' => 1549)),
         $dom->getElementById('1549')
       );
     }
@@ -58,14 +61,12 @@
     public function elementsByName() {
       $dom= Document::fromString('<wizard>
         <step>
-          <form name="package">
-            <select>...</select>
-          </form>
+          <form name="package"><select>...</select></form>
         </step>
       </wizard>');
       
       $this->assertEquals(
-        array($dom->getDocumentElement()->children[0]->children[0]),
+        array(new Node('form', new Node('select', '...'), array('name' => 'package'))),
         $dom->getElementsByName('package')
       );
     }
@@ -90,7 +91,7 @@
       </html>');
       
       $this->assertEquals(
-        $dom->getDocumentElement()->children[1]->children[0]->children[0]->children[0],
+        new Node('li', 'Home', array('id' => 'home')),
         $dom->getElementById('home')
       );
     }
